<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index – GRETL</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-a901c950251d501c967ce3c652c0becd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">GRETL</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../getting_started.html"> 
<span class="menu-text">Get Started</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-documentation" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Documentation</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-documentation">    
        <li>
    <a class="dropdown-item" href="../../../reference.html">
 <span class="dropdown-text">Reference</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../deployment.html">
 <span class="dropdown-text">Deployment</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../development.html">
 <span class="dropdown-text">Development</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-help" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Help</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-help">    
        <li>
    <a class="dropdown-item" href="https://github.com/sogis/gretl/issues"><i class="bi bi-bug" role="img">
</i> 
 <span class="dropdown-text">Report an Issue</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/sogis/gretl/discussions/"><i class="bi bi-chat-right-text" role="img">
</i> 
 <span class="dropdown-text">Discussions</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sogis/gretl"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#developing" id="toc-developing" class="nav-link active" data-scroll-target="#developing">Developing</a>
  <ul class="collapse">
  <li><a href="#interne-struktur" id="toc-interne-struktur" class="nav-link" data-scroll-target="#interne-struktur">Interne Struktur</a>
  <ul class="collapse">
  <li><a href="#versionierung" id="toc-versionierung" class="nav-link" data-scroll-target="#versionierung">Versionierung</a></li>
  <li><a href="#projektstruktur" id="toc-projektstruktur" class="nav-link" data-scroll-target="#projektstruktur">Projektstruktur</a></li>
  <li><a href="#gradle" id="toc-gradle" class="nav-link" data-scroll-target="#gradle">Gradle</a></li>
  <li><a href="#dependencies" id="toc-dependencies" class="nav-link" data-scroll-target="#dependencies">Dependencies</a></li>
  <li><a href="#steps-vs-tasks" id="toc-steps-vs-tasks" class="nav-link" data-scroll-target="#steps-vs-tasks">Steps vs Tasks</a></li>
  <li><a href="#gradle-annotationen" id="toc-gradle-annotationen" class="nav-link" data-scroll-target="#gradle-annotationen">Gradle-Annotationen</a></li>
  <li><a href="#configuring-tasks-lazily" id="toc-configuring-tasks-lazily" class="nav-link" data-scroll-target="#configuring-tasks-lazily">Configuring Tasks Lazily</a></li>
  </ul></li>
  <li><a href="#testing" id="toc-testing" class="nav-link" data-scroll-target="#testing">Testing</a></li>
  <li><a href="#building" id="toc-building" class="nav-link" data-scroll-target="#building">Building</a>
  <ul class="collapse">
  <li><a href="#gradle-plugin" id="toc-gradle-plugin" class="nav-link" data-scroll-target="#gradle-plugin">Gradle-Plugin</a></li>
  <li><a href="#dockerimage" id="toc-dockerimage" class="nav-link" data-scroll-target="#dockerimage">Dockerimage</a></li>
  </ul></li>
  <li><a href="#running" id="toc-running" class="nav-link" data-scroll-target="#running">Running</a></li>
  <li><a href="#dokumentation" id="toc-dokumentation" class="nav-link" data-scroll-target="#dokumentation">Dokumentation</a></li>
  <li><a href="#varia" id="toc-varia" class="nav-link" data-scroll-target="#varia">Varia</a>
  <ul class="collapse">
  <li><a href="#eclipse" id="toc-eclipse" class="nav-link" data-scroll-target="#eclipse">Eclipse</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="developing" class="level1">
<h1>Developing</h1>
<section id="interne-struktur" class="level2">
<h2 class="anchored" data-anchor-id="interne-struktur">Interne Struktur</h2>
<section id="versionierung" class="level3">
<h3 class="anchored" data-anchor-id="versionierung">Versionierung</h3>
<p>Die Version für <em>GRETL</em> wird in der Gradle-Datei <em>versioning.gradle</em> definiert. Es wird nur die Major- und Minor-Version gesetzt. Die Patch-Version soll durch die Pipeline gesetzt werden. Falls lokal gebuildet wird, ist die Patch-Version “LOCALBUILD”.</p>
<p>Ein Minorupdate erfolgte bisher, wenn wir Majorupdates der ilitools durchführten. Oder ausnahmsweisen, wenn Minorupdates der ilitools nicht in jedem Fall rückwärtskompatibel sind.</p>
</section>
<section id="projektstruktur" class="level3">
<h3 class="anchored" data-anchor-id="projektstruktur">Projektstruktur</h3>
<p>Es gibt die beiden Unterprojekte <em>gretl</em> und <em>runtimeImage</em>. Ersteres ist für die eigentliche Entwicklung und das <em>runtimeImage</em>-Unterprojekt dient dem Herstellen des Dockerimages.</p>
</section>
<section id="gradle" class="level3">
<h3 class="anchored" data-anchor-id="gradle">Gradle</h3>
<p><em>GRETL</em> ist ein Gradle Plugin und entsprechend benötigt es die Gradle API. Wenn man Gradle im Projekt updatet, bedeutet dies, dass auch das Plugin mit dieser API-Version entwickelt wird. Das Dockerimage ist entsprechend abzugleichen. Gradle wird im Projekt wie folgt upgedatet:</p>
<pre><code>./gradlew wrapper --gradle-version 8.10.2</code></pre>
<p>Das Dockerimage ist an folgenden Stellen anzupassen:</p>
<pre><code>ENV GRADLE_VERSION 8.10.2
ARG GRADLE_DOWNLOAD_SHA256=31c55713e40233a8303827ceb42ca48a47267a0ad4bab9177123121e71524c26</code></pre>
<p>Ein Update sollte nicht leichtfertig vorgenommen werden, da es verschiedene Auswirkungen haben kann. Andererseits läuft nicht jede Gradle-Version mit jeder neusten Java-Version (was für uns momentan nicht relevant ist).</p>
<p>Die momentan eingesetzte Version 7 funktioniert bis und mit Java 19. Die Version 8 braucht beim allerersten Durchlauf nochmals länger (siehe Kapitel “Running”) und loggt auch mehr im Lifecycle-Level.</p>
</section>
<section id="dependencies" class="level3">
<h3 class="anchored" data-anchor-id="dependencies">Dependencies</h3>
<p><em>GRETL</em> verwendet als Schnittstellenwerkzeug sehr viele Abhängigkeiten, die wiederum Abhängigkeiten verwenden. Aus diesem Grund kann es zu Versionskonflikten führen. Diese können mittels <code>./gradlew gretl:dependencies &gt; dependencies.log</code> herausgefunden werden. Die Konflikte kann man auflösen, indem man z.B. gewissen transitive Abhängigkeiten einer Abhängigkeit exkludiert oder die Version explizit forsiert. Für die ilitools werden die Versionen bewusst forciert. Versionskonflikte können auch das Dockerimage speziell betreffen, da wir dort zusätzlich Gradle-Plugins reinkopieren. In den Ordner <em>stageJars</em> werden sämtliche Jar-Dateien kopiert, was ebenfalls einen guten Überblick gibt. Eine weitere Variante zum Auflösen des Versionskonfliktes von transitiven Abhängigkeiten ist das Verwenden anderer Versionen der Bibliotheken.</p>
</section>
<section id="steps-vs-tasks" class="level3">
<h3 class="anchored" data-anchor-id="steps-vs-tasks">Steps vs Tasks</h3>
<p>Für jeden selber programmierten Customtask gibt es (in der Regel) auch einen dazugehörigen Step. Sämtliche Businesslogik sollte im Step programmiert werden (und ohne Gradle-Abhänigkeiten auskommen). Der Task ist nur die öffentliche API ohne viel mehr Logik.</p>
</section>
<section id="gradle-annotationen" class="level3">
<h3 class="anchored" data-anchor-id="gradle-annotationen">Gradle-Annotationen</h3>
<p>Gradle bietet verschiedene Annotationen für die Task Properties an. So können Properties als optional gekennzeichnet werden oder explizit als Input-Datei. Wird etwas als Input oder Output annotiert, berücksichtig Gradle diese Properties bei der Evaluation, ob ein Task up-to-date ist. Hat sich z.B. ein INTERLIS-Datei nicht geändert, muss sie ja nicht nochmals validiert werden. Wir haben ganz geklärt, ob wir diese Verhalten wünschen. Aus diesem Grund gibt es auch Custom-Tasks, bei denen die Properties mit <code>Internal</code> annotiert sind. Diese Properties werden bei der Evaluierung nicht berücksichtigt. Bei unseren Gretljobs haben wird das so gelöst, dass wir den dazu benötigten Cache explizit im Container behalten und nicht lokal speichern. Ein anderes Dockerimage kann das jedoch anders handhaben. Ebenso beim Einsatz des Gradle-Plugins direkt. Hier dient es sich an, dass mit mit <code>--rerun-tasks</code> das Ausführen der Tasks forciert. Diese Option wird auch bei den Integrationstests verwendet.</p>
</section>
<section id="configuring-tasks-lazily" class="level3">
<h3 class="anchored" data-anchor-id="configuring-tasks-lazily">Configuring Tasks Lazily</h3>
<p>… todo …</p>
</section>
</section>
<section id="testing" class="level2">
<h2 class="anchored" data-anchor-id="testing">Testing</h2>
<p>Es gibt Unit- und Integrationstests. Die Unittests dienen zum Testen der Steps (und einigen anderen Helfer-Klassen). Es gibt zwei zusätzliche Testgruppen, die separat aufgerufen werden müssen: <code>dbTest</code> und <code>s3Test</code>.</p>
<pre><code>./gradlew gretl:test gretl:dbTest gretl:s3Test</code></pre>
<p>Beide benötigten Infrastruktur, die wir via Testcontainers (PostgreSQL und Localstack) bereitstellen. Es finden bereits auch in den “normalen” Tests Datenbanktests statt. In diesem Fall wird eine dateibasierte Datenbank verwendet.</p>
<p>Die Integrationstest sind Tests mit richtigen <em>build.gradle</em>-Dateien und simulieren so die fertige Software. Sie werden zweifach durchgeführt. Zuerst als Gradle-Plugin (“Java pur”) und anschliessend werden alle Jobs nochmals mit dem Dockercontainer geprüft. Aus historischen Gründen (damals kein Localstack verwendet) werden die S3-Tests speziell getaggt.</p>
<p>Nach erfolgreichen Unittests wird das Plugin erstellt und in das lokale Maven-Repository (für das Dockerimage) publiziert:</p>
<pre><code>./gradlew gretl:build gretl:publishPluginMavenPublicationToMavenLocal -x test</code></pre>
<p>Es folgen die Gradle-Plugin-Tests:</p>
<pre><code>./gradlew gretl:jarTest gretl:jarS3Test</code></pre>
<p>Nach dem Builden des Dockerimages</p>
<pre><code>./gradlew runtimeImage:buildImage</code></pre>
<p>folgen die Tests mit dem Dockercontainer:</p>
<pre><code>./gradlew gretl:imageTest gretl:imageS3Test</code></pre>
<p>Die Tests können - wie erwähnt - dank Testcontainers komplett lokal durchgeführt werden. Falls in der Github Action Test fehlschlagen, steht der Report zur Verfügung.</p>
<p>Das Testen des Gradle-Plugins wird mit einem <code>GradleRunner</code> gemacht. Hier ist die Herausforderung, dass der Classpath dem geforkten Java-Prozess (der den Gradle-Job durchführt) bekannt gemacht wird. Nicht ganz nachvollziehbar ist, warum die Lösung mittels <code>.withPluginClasspath()</code> nicht funktioniert. Aus diesem Grund wird der Classpath in eine Datei geschrieben, die wiederum als Grundlage für die Dependencies in der verwendeteten <em>init.gradle</em>-Datei dient. Die Jobs werden mit <code>--rerun-tasks</code> ausgeführt. Dieses Argument ist momentan hardcodiert. Damit wird sichergestellt, dass immer alle Tasks (unabhängig der Annotationen) ausgeführt werden.</p>
</section>
<section id="building" class="level2">
<h2 class="anchored" data-anchor-id="building">Building</h2>
<section id="gradle-plugin" class="level3">
<h3 class="anchored" data-anchor-id="gradle-plugin">Gradle-Plugin</h3>
<p>Das Gradle-Plugin kann problemlos mit Boardmitteln erstellt und publiziert (https://plugins.gradle.org) werden.</p>
</section>
<section id="dockerimage" class="level3">
<h3 class="anchored" data-anchor-id="dockerimage">Dockerimage</h3>
<p>Ziel war es von Beginn weg eine Dockerimage zu erstellen, das sämtliche Abhängigkeiten beinhalten (“offline-fähig”). Das wird erreicht, indem alle Abhängigkeiten zuerst mittel Gradle-Job in den Ordner <em>jars4image</em> kopiert werden (inkl. zusätzlichen Gradle-Plugins).</p>
<p>Die Docker-Befehle sind als Exec-Aufruf ebenfalls im Gradle-Job. Einzig das Einloggen in eine Docker-Registry und das Vorbereiten der buildx-Umgebung wird in der Github Action Konfiguration gemacht (oder muss lokal einmalig gemacht werden). Für die Integrations-Image-Tests wird ein Dockerimage mit dem Tag “test” hergestellt. Erst ganz am Schluss wird der Multi-Arch-Dockerbuild gemacht. Grund dafür ist, dass dieser Build das passende Image nicht in die lokale Registry publiziert und somit auch nicht zur Verfügung steht und vor allem das Publizieren in die externen Registry ist ohne die Build-und-Push-Action sehr mühselig (Manifest-Files etc. pp.).</p>
<p>Für DuckDB werden auch einige Extensions in das Dockerimage gebrannt. Dies ist notwendig, da sonst bei jedem Run die Extension neu installiert (und heruntergeladen) werden müsste. Dazu werden in der <em>stage-duckdb-extensions.gradle</em>-Datei direkt via JDBC die notwendigen Installationsbefehle ausgeführt. Achtung: Die DuckDB-Version muss hier manuell angepasst werden.</p>
</section>
</section>
<section id="running" class="level2">
<h2 class="anchored" data-anchor-id="running">Running</h2>
<p>Gradle cached verschiedene Informationen. Gewisses Verhalten ist von uns eher gewollt als anderes:</p>
<p>Beim Einsatz des Gradle-Plugins (ohne Dockerimage) kann es sein, dass gewisse Tasks nicht durchgeführt werden, weil sich der Input (z.B. eine INTERLIS-Datei) nicht geändert hat. Die Ausführung des Tasks kann man mit <code>--rerun-tasks</code> forcieren. Bei unseren Gretljobs ist dies nicht notwendig, weil wir den Projektcache explizit im Container behalten und nicht lokal mounten (<code>--project-cache-dir=/home/gradle/projectcache</code>).</p>
<p>Beim lokalen Entwickeln ist es jedoch wünschenswert, wenn der Ordner <code>/home/gradle/.gradle/caches</code> gemounted wird, da die Ausführungszeiten (nach der allerersten) massiv schneller werden. Die Integrationstests mit dem Dockerimage werden ebenfalls so durchgeführt, was die Laufzeit auf einen Drittel reduziert (siehe <em>start-gretl.sh</em> und Pipeline “mkdir”). Es scheint auch, dass mit jeder Gradle Major-Version immer mehr beim allerersten Durchlauf evaluiert wird. Das Mounten dieses Caches war mit Gradle Version 5.x noch nicht nötig (resp. war praktisch nicht spürbar). Mit Gradle Version 8.x geht es nochmals länger und es wird auch mehr geloggt.</p>
<p>Es gibt relativ neu (mit Version 7 immer noch experimental) den Konfigurationscache. Dieser müsste freigeschaltet werden, bringt nach einigen Tests jedoch geschwindigkeitsmässig nicht viel. Zudem müssten Tasks umgeschrieben werden, weil nicht mehr auf das Project-Objekt in gleicher, einfacher Form zugegriffen werden kann.</p>
<p>Gradle-Daemons können mit dem Dockerimage nicht persistiert werden (weil der JVM-Prozess mit dem Container stirbt).</p>
</section>
<section id="dokumentation" class="level2">
<h2 class="anchored" data-anchor-id="dokumentation">Dokumentation</h2>
<p>TODO …</p>
</section>
<section id="varia" class="level2">
<h2 class="anchored" data-anchor-id="varia">Varia</h2>
<section id="eclipse" class="level3">
<h3 class="anchored" data-anchor-id="eclipse">Eclipse</h3>
<p>Since <code>java.xml</code> is part of the JDK but is also a dependency of the Gradle API (which is automatically added by the <code>java-gradle-plugin</code>) you will get the famous <code>The package javax.xml.transform.stream is accessible from more than one module: ,java.xml</code> errors. Excluding <code>xml-apis</code> with <code>all*.exclude group: 'xml-apis'</code> should be done but will not work for the Gradle API. Workaround:</p>
<ul>
<li>Clone the repository</li>
<li>Run <code>./gradlew eclipse</code></li>
<li>Add <code>org.eclipse.jdt.core.compiler.ignoreUnnamedModuleForSplitPackage=enabled</code> to <em>gretl/.settings/org.eclipse.jdt.core.prefs</em>.</li>
</ul>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/gretl\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Amt für Geoinformation Kanton Solothurn</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sogis">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/_sogis">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>